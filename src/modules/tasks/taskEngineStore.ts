import { isAfter, isSameDay, parseISO, startOfDay, subDays } from "date-fns";
import type { CurrentUser, LinkedModule, RecurrenceType, Task, TaskPriority, TaskStatus, TaskTemplate, TaskType, UserRole } from "./types";
import { templeEvents } from "@/data/eventData";

const LS_TASKS_KEY = "qoo.tasks.tasks.v1";
const LS_TEMPLATES_KEY = "qoo.tasks.templates.v1";
const LS_TEMPLATE_LAST_GEN_KEY = "qoo.tasks.templateLastGen.v1";
const LS_CURRENT_USER_KEY = "qoo.tasks.currentUser.v1";

type Listener = () => void;

let listeners = new Set<Listener>();

let tasksCache: Task[] | null = null;
let templatesCache: TaskTemplate[] | null = null;
let currentUserCache: CurrentUser | null = null;

function notify() {
  for (const l of listeners) l();
}

function safeJsonParse<T>(raw: string | null): T | null {
  if (!raw) return null;
  try {
    return JSON.parse(raw) as T;
  } catch {
    return null;
  }
}

function loadTasks(): Task[] {
  if (tasksCache) return tasksCache;
  const fromLs = safeJsonParse<Task[]>(localStorage.getItem(LS_TASKS_KEY));
  tasksCache = fromLs && Array.isArray(fromLs) ? fromLs : seedTasks();
  return tasksCache;
}

function loadTemplates(): TaskTemplate[] {
  if (templatesCache) return templatesCache;
  const fromLs = safeJsonParse<TaskTemplate[]>(localStorage.getItem(LS_TEMPLATES_KEY));
  templatesCache = fromLs && Array.isArray(fromLs) ? fromLs : seedTemplates();
  return templatesCache;
}

function persist() {
  if (tasksCache) localStorage.setItem(LS_TASKS_KEY, JSON.stringify(tasksCache));
  if (templatesCache) localStorage.setItem(LS_TEMPLATES_KEY, JSON.stringify(templatesCache));
}

function nowIso() {
  return new Date().toISOString();
}

function newTaskId(prefix = "TSK") {
  const rand = Math.random().toString(16).slice(2, 6).toUpperCase();
  return `${prefix}-${new Date().getFullYear()}-${Date.now().toString().slice(-5)}-${rand}`;
}

export function getCurrentUser(): CurrentUser {
  if (currentUserCache) return currentUserCache;
  const fromLs = safeJsonParse<CurrentUser>(localStorage.getItem(LS_CURRENT_USER_KEY));
  if (fromLs?.userId && fromLs?.displayName && fromLs?.role) {
    currentUserCache = fromLs;
    return currentUserCache;
  }
  currentUserCache = { userId: "USR-ADMIN", displayName: "Temple Admin", role: "Admin" };
  localStorage.setItem(LS_CURRENT_USER_KEY, JSON.stringify(currentUserCache));
  return currentUserCache;
}

export function setCurrentUserRole(role: UserRole) {
  const cur = getCurrentUser();
  const next: CurrentUser = { ...cur, role };
  currentUserCache = next;
  localStorage.setItem(LS_CURRENT_USER_KEY, JSON.stringify(next));
  notify();
}

export function subscribe(listener: Listener) {
  listeners.add(listener);
  return () => listeners.delete(listener);
}

export function getTasks(): Task[] {
  // IMPORTANT: must be referentially stable for useSyncExternalStore snapshots.
  // We only replace the array when tasks actually change (setTasks).
  return loadTasks();
}

export function getTemplates(): TaskTemplate[] {
  // IMPORTANT: must be referentially stable for useSyncExternalStore snapshots.
  // We only replace the array when templates actually change (setTemplates).
  return loadTemplates();
}

export function isTaskOverdue(task: Task, asOf = new Date()): boolean {
  if (task.status === "Completed") return false;
  if (task.status === "Cancelled") return false;
  const due = parseISO(task.dueDate);
  return isAfter(startOfDay(asOf), startOfDay(due));
}

export function isDueToday(task: Task, asOf = new Date()): boolean {
  const due = parseISO(task.dueDate);
  return isSameDay(due, asOf) && task.status !== "Completed" && task.status !== "Cancelled";
}

function setTasks(next: Task[]) {
  tasksCache = next;
  persist();
  notify();
}

function setTemplates(next: TaskTemplate[]) {
  templatesCache = next;
  persist();
  notify();
}

export function createTask(input: Omit<Task, "taskId" | "createdAt" | "completedAt"> & { taskId?: string; createdAt?: string; completedAt?: string | null }) {
  const createdAt = input.createdAt ?? nowIso();
  const taskId = input.taskId ?? newTaskId();
  const completedAt = input.status === "Completed" ? (input.completedAt ?? nowIso()) : null;

  const task: Task = {
    taskId,
    title: input.title,
    description: input.description,
    type: input.type,
    linkedModule: input.linkedModule,
    linkedId: input.linkedId,
    priority: input.priority,
    status: input.status,
    assignedTo: input.assignedTo,
    assignedBy: input.assignedBy,
    dueDate: input.dueDate,
    createdAt,
    completedAt,
    isAutoGenerated: input.isAutoGenerated,
  };

  const tasks = loadTasks();
  setTasks([task, ...tasks]);
  return task;
}

export function updateTaskStatus(taskId: string, status: TaskStatus) {
  const tasks = loadTasks();
  const next = tasks.map((t) => {
    if (t.taskId !== taskId) return t;
    return {
      ...t,
      status,
      completedAt: status === "Completed" ? nowIso() : null,
    };
  });
  setTasks(next);
}

export function upsertTemplate(template: TaskTemplate) {
  const templates = loadTemplates();
  const idx = templates.findIndex((t) => t.templateId === template.templateId);
  const next = idx === -1 ? [template, ...templates] : templates.map((t) => (t.templateId === template.templateId ? template : t));
  setTemplates(next);
}

export function deleteTemplate(templateId: string) {
  const templates = loadTemplates();
  setTemplates(templates.filter((t) => t.templateId !== templateId));
}

function recurrenceAllowsDate(recurrenceType: RecurrenceType, start: Date, day: Date): boolean {
  // very simple cadence rule for demo:
  // - Daily: any day >= start
  // - Weekly: same weekday as start
  // - Monthly: same date-of-month as start
  // - Yearly: same month+date as start
  if (isAfter(startOfDay(start), startOfDay(day))) return false;

  if (recurrenceType === "Daily") return true;
  if (recurrenceType === "Weekly") return start.getDay() === day.getDay();
  if (recurrenceType === "Monthly") return start.getDate() === day.getDate();
  return start.getDate() === day.getDate() && start.getMonth() === day.getMonth();
}

function templateDueToday(template: TaskTemplate, asOf: Date): boolean {
  if (!template.isActive) return false;
  const start = parseISO(template.startDate);
  const end = template.endDate ? parseISO(template.endDate) : null;
  if (end && isAfter(startOfDay(asOf), startOfDay(end))) return false;
  return recurrenceAllowsDate(template.recurrenceType, start, asOf);
}

function getTemplateLastGenMap(): Record<string, string> {
  return safeJsonParse<Record<string, string>>(localStorage.getItem(LS_TEMPLATE_LAST_GEN_KEY)) ?? {};
}

function setTemplateLastGen(templateId: string, dateIso: string) {
  const map = getTemplateLastGenMap();
  map[templateId] = dateIso;
  localStorage.setItem(LS_TEMPLATE_LAST_GEN_KEY, JSON.stringify(map));
}

export function generateTasksFromTemplates(asOf = new Date()) {
  const templates = loadTemplates();
  const lastGen = getTemplateLastGenMap();
  const todayKey = startOfDay(asOf).toISOString();

  for (const tpl of templates) {
    if (!templateDueToday(tpl, asOf)) continue;
    if (lastGen[tpl.templateId] && isSameDay(parseISO(lastGen[tpl.templateId]), asOf)) continue;

    createTask({
      title: tpl.title,
      description: tpl.description,
      type: "System",
      linkedModule: "ScheduledTemplate",
      linkedId: tpl.templateId,
      priority: tpl.priority,
      status: "Pending",
      assignedTo: tpl.defaultAssignee,
      assignedBy: "System",
      dueDate: startOfDay(asOf).toISOString(),
      isAutoGenerated: true,
    });

    setTemplateLastGen(tpl.templateId, todayKey);
  }
}

function taskExistsOpen(match: Pick<Task, "linkedModule" | "linkedId" | "title">): boolean {
  const tasks = loadTasks();
  return tasks.some(
    (t) =>
      t.linkedModule === match.linkedModule &&
      t.linkedId === match.linkedId &&
      t.title === match.title &&
      t.status !== "Completed" &&
      t.status !== "Cancelled",
  );
}

export function runEventIntegrations(asOf = new Date()) {
  // Event → tasks
  for (const ev of templeEvents) {
    if (ev.status === "Archived") continue;
    const due = subDays(parseISO(ev.startDate), 1);
    const t1 = `Prepare materials – ${ev.name}`;
    const t2 = `Assign priest – ${ev.name}`;
    if (!taskExistsOpen({ linkedModule: "Event", linkedId: ev.id, title: t1 })) {
      createTask({
        title: t1,
        description: `Prepare event materials and checklists for ${ev.name}.`,
        type: "Event",
        linkedModule: "Event",
        linkedId: ev.id,
        priority: "High",
        status: "Pending",
        assignedTo: "Event Manager",
        assignedBy: "System",
        dueDate: due.toISOString(),
        isAutoGenerated: true,
      });
    }
    if (!taskExistsOpen({ linkedModule: "Event", linkedId: ev.id, title: t2 })) {
      createTask({
        title: t2,
        description: `Assign priest and confirm ritual schedule for ${ev.name}.`,
        type: "Event",
        linkedModule: "Event",
        linkedId: ev.id,
        priority: "High",
        status: "Pending",
        assignedTo: "Event Manager",
        assignedBy: "System",
        dueDate: due.toISOString(),
        isAutoGenerated: true,
      });
    }
  }
}

export function getViewSourcePath(task: Task): string | null {
  if (task.linkedModule === "Event") return `/temple/events/${task.linkedId}`;
  if (task.linkedModule === "Inventory") return `/temple/inventory/items/${task.linkedId}`;
  if (task.linkedModule === "Purchase") return `/temple/inventory/purchases/${task.linkedId}`;
  if (task.linkedModule === "Kitchen") return `/temple/prasadam/batches`;
  if (task.linkedModule === "Assignment") return `/temple/freelancers`;
  if (task.linkedModule === "HR") return `/temple/people`;
  if (task.linkedModule === "ScheduledTemplate") return `/temple/tasks/templates`;
  return null;
}

export function canViewTask(user: CurrentUser, task: Task): boolean {
  if (user.role === "Admin") return true;
  if (user.role === "Finance") return task.linkedModule === "Purchase";
  if (user.role === "Store Manager") return task.linkedModule === "Inventory" || task.linkedModule === "Purchase";
  if (user.role === "Event Manager") return task.linkedModule === "Event";
  return false;
}

export function canCompleteTask(user: CurrentUser, task: Task): boolean {
  if (user.role === "Admin") return true;
  if (task.linkedModule === "Inventory" && user.role === "Store Manager") return true;
  if (task.linkedModule === "Event" && user.role === "Event Manager") return true;
  return false;
}

// -------------------------
// Seeds (demo data)
// -------------------------
function seedTasks(): Task[] {
  const createdAt = "2026-02-10T09:00:00.000Z";
  return [
    {
      taskId: "TSK-001",
      title: "Prepare materials – Maha Shivaratri",
      description: "Prepare event materials and checklists for Maha Shivaratri.",
      type: "Event",
      linkedModule: "Event",
      linkedId: "EVT-004",
      priority: "High",
      status: "Pending",
      assignedTo: "Event Manager",
      assignedBy: "System",
      dueDate: "2026-02-14T00:00:00.000Z",
      createdAt,
      completedAt: null,
      isAutoGenerated: true,
    },
    {
      taskId: "TSK-003",
      title: "Assign priest – Maha Shivaratri",
      description: "Assign priest and confirm ritual schedule for Maha Shivaratri.",
      type: "Event",
      linkedModule: "Event",
      linkedId: "EVT-004",
      priority: "High",
      status: "Pending",
      assignedTo: "Event Manager",
      assignedBy: "System",
      dueDate: "2026-02-14T00:00:00.000Z",
      createdAt,
      completedAt: null,
      isAutoGenerated: true,
    },
    {
      taskId: "TSK-004",
      title: "Clean Hall A",
      description: "Deep clean and ready for evening program.",
      type: "Manual",
      linkedModule: "Manual",
      linkedId: "TSK-005",
      priority: "Low",
      status: "Completed",
      assignedTo: "Maintenance Crew",
      assignedBy: "Temple Admin",
      dueDate: "2026-02-09T00:00:00.000Z",
      createdAt: "2026-02-09T08:00:00.000Z",
      completedAt: "2026-02-09T17:30:00.000Z",
      isAutoGenerated: false,
    },
  ];
}

function seedTemplates(): TaskTemplate[] {
  return [
    {
      templateId: "TPL-001",
      title: "Weekly stock audit (Main Store)",
      description: "Check physical vs system quantities and log adjustments.",
      linkedModule: "Inventory",
      priority: "Medium",
      defaultAssignee: "Store Manager",
      recurrenceType: "Weekly",
      startDate: "2026-02-03",
      endDate: null,
      timeOfDay: "10:00",
      isActive: true,
    },
    {
      templateId: "TPL-002",
      title: "Monthly donation report",
      description: "Generate and review monthly donations report.",
      linkedModule: "System",
      priority: "High",
      defaultAssignee: "Finance",
      recurrenceType: "Monthly",
      startDate: "2026-02-01",
      endDate: null,
      timeOfDay: "18:00",
      isActive: true,
    },
  ];
}

